//Andre Barajas
//CS 444 
//FALL 2018
//Parser for compiler program for a6 LEXCON language

//loading needed libraries and classes
package parser;

import lexer.Token;
import lexer.Tokenizer;
import parser.pst.Node;
import parser.pst.ASTConverter;

import java.util.ArrayList;
import java.util.Stack;

public class Parser
{

    private static Stack<Node> inputStack;
    private static ArrayList<Token> tokens;
    private static Node root;
    
    
    public static void main(String args[]) 
    {
        Node astRoot = getASTRoot(true);
        printTree(astRoot, 0);
    }//ending main method

    public static Node getASTRoot(boolean printThisPST) 
    {
        ParseTable table = init();
        if (table == null) 
        {
            System.out.println("Error: Tokenizer failed to initiate");
            System.exit(1);
        }//ending if condition statement for error

        while(!inputStack.empty())
        {
            String currentStackTop = inputStack.peek().getKeyword();
            String currentInputFront = tokens.get(0).getGrammar().getKeyword();

            System.out.println("-----------------------------");
            System.out.println("Stack top: "+currentStackTop);
            System.out.println("Stream front: "+currentInputFront);
            
            
            if (currentStackTop.equals(currentInputFront) || currentStackTop.equals("$")) 
            {
            	System.out.println("\n<inside m1 condition>");
                m1();
            } else if (m2(currentStackTop)) 
            {
            	System.out.println("\n<inside m2 condition>");
                error("M2");
            } else 
            {
                Rule currentRule = table.get(currentStackTop, currentInputFront);
                
                if (currentRule != null)
                	System.out.println("Rule ID: "+currentRule.getId());
                
                if (m3(currentRule)) 
                {
                	System.out.println("\n<inside m3 condition>");
                	//break;
                    error("M3");
                } else 
                {
                	System.out.println("\n<inside m4 condition>");
                    m4(currentRule);
                } //Ending nested if else condition statement
            } // Ending nested if else condition statement
        } // Ending while loop condition statement

        System.out.println(printThisPST);
        if (printThisPST)
            printTree(root, 0);
        //Ending if condition statement
        return ASTConverter.convert(root);
    } // Ending getASTRoon function 

   
    //function to start the ll parse table to read from 
    private static ParseTable init()
    {
        //Tokenizer tokenizer = new Tokenizer("program.txt");
    	Tokenizer tokenizer = new Tokenizer("./lexer/A4-sample.acod");

        tokens = tokenizer.printTokens();
 
        
        //ending if condition statement
        if (tokens == null || tokens.isEmpty())
            return null;
        //ending if condition statement
        inputStack = new Stack<Node>();
        root = new Node("Pgm");
        inputStack.push(root);

        return new ParseTable();
    }//ending init function
    
    //function to pop any node from the top of the stack and adds value to front of the input stream
    private static void m1() 
    {
        Node poppedNode = inputStack.pop();
        Token poppedToken = tokens.remove(0);

        poppedNode.setValue(poppedToken.getValue());
    }

    //function to return i the top stack is terminal symb.
    private static boolean m2(String currentTop)
    {
        return !currentTop.isEmpty() && Character.isLowerCase(currentTop.charAt(0));
    }

    private static boolean m3(Rule currentRule) 
    {
        return currentRule == null;
    }

  
    
    //pops if epsilon rule is present or for matching rule
    private static void m4(Rule currentRule) 
    {
        if (currentRule.isEpsilonRule()) 
        {
            inputStack.pop();
        } else 
        {
            Node parent = inputStack.pop();

            // SYSOUT
            System.out.println("LHS: "+currentRule.getLhs()+" RHS: "+currentRule.getRhs());
            String[] reversed = currentRule.getReversedRhsArray();
            for (String keyword : reversed) 
            {
            	System.out.println("kw: "+keyword);
                Node child = new Node(keyword);
                parent.addChild(child);
                inputStack.push(child);
            }//ending for loop statement
        }//ending if else condition statement
    }

    private static void error(String currentError)
    {
        System.out.println(currentError + " ERROR.");
        System.exit(1);
    }

  
    //pre order print of the tree 
    public static void printTree(Node rootNode, int nodeLevel) 
    {
        if (rootNode == null)
            return;
        //ending if condition statement
        String tab = getSpacing(nodeLevel);
        System.out.println(tab + "(" + rootNode + ")");

        nodeLevel++;
        ArrayList<Node> children = rootNode.getChildren();
        for (Node child : children)
        {
            printTree(child, nodeLevel);
        }//ending enhanced for loop statement
    }
    //function used in tree printing
    private static String getSpacing(int nodeLevel)
    {
        String data = "";
        for (int i = 0; i < nodeLevel; i++)
        	data = data + "  ";
        //ending for loop statement

        return data;
    }
} //Ending Parser class
